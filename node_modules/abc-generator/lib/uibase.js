var fs = require('fs');
var path = require('path');
var generator = require('yeoman-generator');
var util = require('util');
var Base = generator.Base;
var logging = process.logging;
var _ = require('lodash');
var exists = fs.existsSync || path.existsSync;
var async = require('async');

// The `NamedBase` object is only dealing with one argument: `name`.
//
// You can use it whenever you need at least one **required** positional
// argument for your generator (which is a fairly common use case)
//
// - args - A String or Array of arguments to init the generator with.
// - opts - A Hash of options to init the generator with.
function UIBase(args, options) {
  Base.apply(this, arguments);
  options = options || {};

  this.abcLogo =
    '   _____ ___________________  \n' +
    '  /  _  \\\\______   \\_   ___ \\ \n' +
    ' /  /_\\  \\|    |  _/    \\  \\/ \n' +
    '/    |    |    |   \\     \\____\n' +
    '\\____|__  |______  /\\______  /\n' +
    '        \\/       \\/        \\/ \n';
  if (this.generatorName) {

    this.abcLogo += '\n';

    var headingLen = Math.floor( (28 - this.generatorName.length) / 2);
    var tailLen = 28 - headingLen - this.generatorName.length;
    var name = '';

    _.times(headingLen, function() {
      name += '❯';
    });

    name += ' ' + this.generatorName.toUpperCase().green + ' ';

    _.times(tailLen, function() {
      name += '❮';
    });

    this.abcLogo += name + '\n';
  }

  this.enableUI = options.enableUI;

  if (this.enableUI) {
    this.uiRoot = options.uiRoot || require('path').resolve(__dirname, '../../../ui');
    this.UISetup();
  }
}

util.inherits(UIBase, Base);


// Get the UI for this generator
UIBase.prototype.ui = function () {
  return {
    html: '',
    javascript: 'alert("from ui base!")',
    css: ''
  }
};

UIBase.prototype.UISetup = function UISetup() {
  var self = this;

  var log = self.log;


  self.scan = self._scan || function () {
    return {
      'message': 'Please override this function'
    }
  };


  self._uiConflicts = [];

  // rewrite conflicter's resolve method
  self.conflicter.resolve = function(callback) {

    if (!self._uiConflicts.length) {
      callback();
      return;
    }

    async.forEachSeries(self._uiConflicts, function(conflict, callback) {

      var filepath = conflict.filepath;
      var cb = conflict.callback;
      var content = conflict.content;
      var replaceContent = conflict.replaceContent;

      if (self.force) {
        log.force(filepath);
        cb(null, 'force');
        callback();
        return
      }

      self.emit('conflict', {
        filepath: filepath,
        content: content,
        replaceContent: replaceContent
      });

      self.once('resolved:' + filepath, function(method) {

        if (method === 'quit') {
          log.error('quit process by resolve!');
          process.exit(0);
        }

        if (method === 'skip') {
          log.skip(filepath);
          cb(null, 'skip');
        }

        if (method === 'overwrite') {
          log.force(filepath);
          cb(null, 'overwrite');
        }

        if (method === 'overwriteAll') {
          log.force(filepath);
          self.force = true;
          cb(null, 'overwrite');
        }

        // callback for async
        callback();
      });

    }, callback);

    self._uiConflicts = [];

  };

  _.extend(self, {
    /**
     * reWrite prompt for ui use
     * @param prompts
     * @param done
     */
    prompt: function(prompts, done) {
      this.emit('prompt', prompts);

      this.once('resolve-prompt', function (args) {
        done(args[0],args[1]);
      }.bind(this));

    },

    checkForCollision: function (filepath, content, cb) {
      var log = this.log;

      if (!filepath) {
        throw new Error('Missing filepath option');
      }

      if (content === undefined) {
        throw new Error('Missing content option');
      }

      if (!exists(filepath)) {
        log.create(filepath);
        return cb(null, 'create');
      }

      // TODO(mklabs): handle non utf8 file (images, etc.) and compare mtime instead,
      // something like that.
      var actual = fs.readFileSync(path.resolve(filepath), 'utf8');

      if (actual === content) {
        log.identical(filepath);
        return cb(null, 'identical');
      }

      if (this.force) {
        log.force(filepath);
        return cb(null, 'force');
      }

      this._uiConflicts.push({
        filepath: filepath,
        replaceContent: content,
        content: actual,
        callback: cb
      });


    },

    /**
     * Resolve Prompts
     * @param err {Error} error obj
     * @param props {Object} the resolve props
     */
    resolvePrompt: function (err, props) {
      this.emit('resolve-prompt', arguments);
    },

    /**
     * resolve file conflict
     * @param filepath {String} path to resolve
     * @param method {String} resolve method
     */
    resolveConflict: function(filepath, method) {
      this.emit('resolved:' + filepath, method);
    },

    getUI: function getUI() {

      if (!this.resolved) {
        return {};
      }

      var uiRoot = path.join(this.resolved, '../../ui');

      return {
        uiRoot: uiRoot,
        html: readfile(path.join(uiRoot, 'app.html'))
      }
    },

    invoke: function(name, attr, callback) {
      console.log("for Now, ABC-UI can\'t invoke sub generator:" + name + ", Please run it later!\n\n");
      callback()
    }
  });
};

function readfile(pathname) {
  var content = null;

  try {
    if (fs.existsSync(pathname))
      content = fs.readFileSync(pathname, 'utf-8');
  } catch (e) {

  }

  return content;
}

module.exports = UIBase;